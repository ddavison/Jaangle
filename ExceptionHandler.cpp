// ExceptionHandler.cpp  Version 1.1
//
// Copyright © 1998 Bruce Dawson
//
// This source file contains the exception handler for recording error
// information after crashes. See ExceptionHandler.h for information
// on how to hook it in.
//
// Author:       Bruce Dawson
//               brucedawson@cygnus-software.com
//
// Modified by:  Hans Dietrich
//               hdietrich2@hotmail.com
//
// Version 1.1:  - reformatted output for XP-like error report
//               - added ascii output to stack dump
//
// A paper by the original author can be found at:
//     http://www.cygnus-software.com/papers/release_debugging.html
//
///////////////////////////////////////////////////////////////////////////////

// Disable warnings generated by the Windows header files.
#pragma warning(disable : 4514)
#pragma warning(disable : 4201)

#include "stdafx.h"
#include "ExceptionHandler.h"

static DWORD sMainThread = 0;
LONG WINAPI AppUnhandledExceptionFilter(_EXCEPTION_POINTERS* pExceptPtrs)
{
	RecordExceptionInfo(pExceptPtrs, GetCurrentThreadId() == sMainThread ? "Main Thread" : "Child Thread");
	TerminateProcess(GetCurrentProcess(), -1);
	return 0;
}


LONG WINAPI DummyUnhandledExceptionFilter(_EXCEPTION_POINTERS* pExceptPtrs)
{
	return NULL;
}

//=== http://blog.kalmbachnet.de/?postid=75
BOOL PreventSetUnhandledExceptionFilter()
{
	HMODULE hKernel32 = LoadLibrary(_T("kernel32.dll"));
	if (hKernel32 ==  NULL) return FALSE;
	void *pOrgEntry = GetProcAddress(hKernel32, "SetUnhandledExceptionFilter");
	if(pOrgEntry == NULL) return FALSE;
	unsigned char newJump[ 100 ];
	DWORD dwOrgEntryAddr = (DWORD) pOrgEntry;
	dwOrgEntryAddr += 5; // add 5 for 5 op-codes for jmp far
	void *pNewFunc = &DummyUnhandledExceptionFilter;
	DWORD dwNewEntryAddr = (DWORD) pNewFunc;
	DWORD dwRelativeAddr = dwNewEntryAddr - dwOrgEntryAddr;

	newJump[ 0 ] = 0xE9;  // JMP absolute
	memcpy(&newJump[ 1 ], &dwRelativeAddr, sizeof(pNewFunc));
	SIZE_T bytesWritten;
	BOOL bRet = WriteProcessMemory(GetCurrentProcess(),
		pOrgEntry, newJump, sizeof(pNewFunc) + 1, &bytesWritten);
	return bRet;
}


//=== Override AfxWinMain
int AFXAPI AfxWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
					  __in LPTSTR lpCmdLine, int nCmdShow)
{
	//Set the filter
	sMainThread = GetCurrentThreadId();
	SetUnhandledExceptionFilter(&AppUnhandledExceptionFilter);
	PreventSetUnhandledExceptionFilter();
	//END

	ASSERT(hPrevInstance == NULL);

	int nReturnCode = -1;
	CWinThread* pThread = AfxGetThread();
	CWinApp* pApp = AfxGetApp();

	// AFX internal initialization
	if (!AfxWinInit(hInstance, hPrevInstance, lpCmdLine, nCmdShow))
		goto InitFailure;

	// App global initializations (rare)
	if (pApp != NULL && !pApp->InitApplication())
		goto InitFailure;

	// Perform specific initializations
	if (!pThread->InitInstance())
	{
		if (pThread->m_pMainWnd != NULL)
		{
			//TRACE(traceAppMsg, 0, _T("Warning: Destroying non-NULL m_pMainWnd\n"));
			pThread->m_pMainWnd->DestroyWindow();
		}
		nReturnCode = pThread->ExitInstance();
		goto InitFailure;
	}
	nReturnCode = pThread->Run();

InitFailure:
#ifdef _DEBUG
	// Check for missing AfxLockTempMap calls
	if (AfxGetModuleThreadState()->m_nTempMapLock != 0)
	{
		//TRACE(traceAppMsg, 0, _T("Warning: Temp map lock count non-zero (%ld).\n"),
		//	AfxGetModuleThreadState()->m_nTempMapLock);
	}
	AfxLockTempMaps();
	AfxUnlockTempMaps(-1);
#endif

	AfxWinTerm();
	return nReturnCode;
}



const int NumCodeBytes = 16;	// Number of code bytes to record.
const int MaxStackDump = 3072;	// Maximum number of DWORDS in stack dumps.
const int StackColumns = 4;		// Number of columns in stack dump.


static void LogWrite(HANDLE LogFile, LPCSTR Format, ...)
{
	const UINT bfLen = 8*1024;				// must be at least 2048
	CHAR bf[bfLen];
	va_list arglist;
	va_start( arglist, Format);
	_vsnprintf(bf, bfLen, Format, arglist);
	va_end(arglist);
	DWORD bytesWritten;
	WriteFile(LogFile, bf, strlen(bf), &bytesWritten, 0);
}

static const CHAR *GetExceptionDescription(DWORD ExceptionCode)
{
	struct ExceptionNames
	{
		DWORD	ExceptionCode;
		CHAR*	ExceptionName;
	};
	ExceptionNames ExceptionMap[] =
	{
		{0x40010005, "a Control-C"},
		{0x40010008, "a Control-Break"},
		{0x80000002, "a Datatype Misalignment"},
		{0x80000003, "a Breakpoint"},
		{0xc0000005, "an Access Violation"},
		{0xc0000006, "an In Page Error"},
		{0xc0000017, "a No Memory"},
		{0xc000001d, "an Illegal Instruction"},
		{0xc0000025, "a Noncontinuable Exception"},
		{0xc0000026, "an Invalid Disposition"},
		{0xc000008c, "a Array Bounds Exceeded"},
		{0xc000008d, "a Float Denormal Operand"},
		{0xc000008e, "a Float Divide by Zero"},
		{0xc000008f, "a Float Inexact Result"},
		{0xc0000090, "a Float Invalid Operation"},
		{0xc0000091, "a Float Overflow"},
		{0xc0000092, "a Float Stack Check"},
		{0xc0000093, "a Float Underflow"},
		{0xc0000094, "an Integer Divide by Zero"},
		{0xc0000095, "an Integer Overflow"},
		{0xc0000096, "a Privileged Instruction"},
		{0xc00000fD, "a Stack Overflow"},
		{0xc0000142, "a DLL Initialization Failed"},
		{0xe06d7363, "a Microsoft C++ Exception"},
	};

	for (int i = 0; i < sizeof(ExceptionMap) / sizeof(ExceptionMap[0]); i++)
		if (ExceptionCode == ExceptionMap[i].ExceptionCode)
			return ExceptionMap[i].ExceptionName;

	return "an Unknown exception type";
}

//=== Runs when the thread crashed
int __cdecl RecordExceptionInfo(PEXCEPTION_POINTERS pExceptPtrs, 
								LPCSTR lpszMessage)
{
	static bool bFirstTime = true;
	if (!bFirstTime)	// Going recursive! That must mean this routine crashed!
		return EXCEPTION_CONTINUE_SEARCH;
	if (pExceptPtrs == NULL)
		return EXCEPTION_CONTINUE_SEARCH;
	bFirstTime = false;

	LPCTSTR files[] = CRASHREPORT_FILES;
	if (files[0] == NULL)
		return EXCEPTION_CONTINUE_SEARCH;

	TCHAR appPath[_MAX_PATH];
	if (::GetModuleFileName(0, appPath, _MAX_PATH) == 0)//=== GetModuleFileName FAILED
		return EXCEPTION_CONTINUE_SEARCH;
	LPTSTR pszSlash = _tcsrchr(appPath, '\\');
	if (pszSlash == NULL)//=== GetModuleFileName (possibly) FAILED
		return EXCEPTION_CONTINUE_SEARCH;
	pszSlash++;
	*pszSlash = 0;

	TCHAR logPath[_MAX_PATH];
	_sntprintf(logPath, _MAX_PATH, _T("%s%s"), appPath, files[0]);


	HANDLE hLogFile = CreateFile(logPath, GENERIC_WRITE, 0, 0,
				CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, 0);

	if (hLogFile != INVALID_HANDLE_VALUE)
	{
		CHAR exePath[_MAX_PATH];
		if (::GetModuleFileNameA(0, exePath, _MAX_PATH) == 0)//=== GetModuleFileName FAILED
			return EXCEPTION_CONTINUE_SEARCH;
		//=== Write the exe path
		LogWrite(hLogFile, "Executable path: %s\r\n", exePath);
		//=== Write the message (Thread name)
		LogWrite(hLogFile, "Thread name: %s (0x%X)\r\n", lpszMessage, GetCurrentThreadId());
		//=== Write the crash Module
		PEXCEPTION_RECORD Exception = pExceptPtrs->ExceptionRecord;
		PCONTEXT          Context   = pExceptPtrs->ContextRecord;

		MEMORY_BASIC_INFORMATION MemInfo;
		if (VirtualQuery((void*)Context->Eip, &MemInfo, sizeof(MemInfo)))
		{
			CHAR bf[1000];
			if (GetModuleFileNameA((HINSTANCE)MemInfo.AllocationBase, bf, 1000) > 0)
				LogWrite(hLogFile, "Crash Module: %s\r\n", bf);
		}
		LogWrite(hLogFile, "Description: %s (0x%08x) at %04x:%08x.\r\n", 
			GetExceptionDescription(Exception->ExceptionCode), 
			Exception->ExceptionCode,
			Context->SegCs, Context->Eip);
		// If the exception was an access violation, print out some additional
		// information, to the error log and the debugger.
		if (Exception->ExceptionCode == STATUS_ACCESS_VIOLATION &&
					Exception->NumberParameters >= 2)
		{
			const CHAR* readwrite = "Read from";
			if (Exception->ExceptionInformation[0])
				readwrite = "Write to";
			LogWrite(hLogFile, "More Details: Read From location %08x caused an access violation.\r\n",
						Exception->ExceptionInformation[1]);
		}

		LogWrite(hLogFile, "\r\n");
		LogWrite(hLogFile, "Context:\r\n");
		LogWrite(hLogFile, "EDI:    0x%08x  ESI: 0x%08x  EAX:   0x%08x\r\n",
			Context->Edi, Context->Esi, Context->Eax);
		LogWrite(hLogFile, "EBX:    0x%08x  ECX: 0x%08x  EDX:   0x%08x\r\n",
			Context->Ebx, Context->Ecx, Context->Edx);
		LogWrite(hLogFile, "EIP:    0x%08x  EBP: 0x%08x  SegCs: 0x%08x\r\n",
			Context->Eip, Context->Ebp, Context->SegCs);
		LogWrite(hLogFile, "EFlags: 0x%08x  ESP: 0x%08x  SegSs: 0x%08x\r\n",
			Context->EFlags, Context->Esp, Context->SegSs);
		CloseHandle(hLogFile);
	}

	if (FALSE) //************************ TEMPORARY //IsDebuggerPresent())
	{
		// let the debugger catch this -
		// return the magic value which tells Win32 that this handler didn't
		// actually handle the exception - so that things will proceed as per
		// normal.
		return EXCEPTION_CONTINUE_SEARCH;
	}
	else
	{
		///////////////////////////////////////////////////////////////////////
		//
		//  pop up our crash report app
		//
		///////////////////////////////////////////////////////////////////////

		// Replace the filename with our crash report exe file name
		TCHAR reportExe[_MAX_PATH];
		_sntprintf(reportExe, _MAX_PATH, _T("%s%s"), appPath, CRASHREPORT_EXENAME);
		//TCHAR szCommandLine[MAX_PATH];
		//lstrcpy(szCommandLine, reportExe);

		STARTUPINFO si;
		ZeroMemory(&si, sizeof(si));
		si.cb = sizeof(si);
		si.dwFlags = STARTF_USESHOWWINDOW;
		si.wShowWindow = SW_SHOW;

		PROCESS_INFORMATION pi;
		ZeroMemory(&pi, sizeof(pi));

		if (CreateProcess(
			reportExe,				// name of executable module
			_T("start"),			// command line string
			NULL,					// process attributes
			NULL,					// thread attributes
			FALSE,					// handle inheritance option
			0,						// creation flags
			NULL,					// new environment block
			NULL,					// current directory name
			&si,					// startup information
			&pi))					// process information
		{
			// XCrashReport.exe was successfully started, so
			// suppress the standard crash dialog
			return EXCEPTION_EXECUTE_HANDLER;
		}
		else
		{
			// XCrashReport.exe was not started - let
			// the standard crash dialog appear
			return EXCEPTION_CONTINUE_SEARCH;
		}
	}




	// return the magic value which tells Win32 that this handler didn't
	// actually handle the exception - so that things will proceed as per
	// normal.
	return EXCEPTION_CONTINUE_SEARCH;
}
